#! /usr/bin/python

import libmatrix, traceback, numpy


def test( nprocs, size ):

  print 'testing on %d processors' % nprocs
  print 'total dofs:', size

  dofs = numpy.arange( size )
  bounds = ( (size-1) * numpy.arange( nprocs+1, dtype=float ) / nprocs ).astype( int )
  print bounds

  print 'dof assignments:'
  dofmap = map( range, bounds[:-1], bounds[1:]+1 )
  for iproc, dofs in enumerate( dofmap ):
    print '  proc %d:' % iproc, dofs

  block = numpy.array([[1,-1],[-1,1]])
  print 'block:'
  print block

  print 'sparsity:'
  nzmap = [ [ dofs[max(0,idof-1):idof+2] for idof in range( len(dofs) ) ] for iproc, dofs in enumerate( dofmap ) ]
  for iproc, nz in enumerate( nzmap ):
    print '  proc %d:' % iproc, nz

  comm = libmatrix.LibMatrix( nprocs=nprocs )

  m = libmatrix.Map( comm, globs=dofmap )

  v = libmatrix.Vector( comm, size, m )
  for iproc, dofs in enumerate( dofmap ):
    values = (numpy.array(dofs)+1)*10
    values[0] /= 2
    values[-1] /= 2
    print 'adding', values, ' to ', dofs, ' on proc', iproc
    v.add( rank=iproc, idx=dofs, data=values )

  print 'resulting vector:', v.toarray()

  v_npy = numpy.arange(1,size+1) * 10
  v_npy[0] /= 2
  v_npy[1] /= 2

  print 'reference vector:', v.toarray()

  graph = libmatrix.Graph( comm, m, rows=nzmap )

  A = libmatrix.Matrix( comm, (size,size), graph )
  for iproc, dofs in enumerate( dofmap ):
    for idx in zip( dofs[:-1], dofs[1:] ):
      print 'adding block to ', idx, ' on proc', iproc
      A.add( rank=iproc, rowidx=idx, colidx=idx, data=block )

  A.complete()

  A_npy = numpy.eye(size,size) * 2 - numpy.eye(size,size,1) - numpy.eye(size,size,-1)
  A_npy[0,0] = A_npy[-1,-1] = 1

  print 'libmatrix norm:', A.norm()
  print 'reference norm:', numpy.sqrt( ( A_npy**2 ).sum() )

  print 'multiplying matrix and vector'
  w = A.matvec( v )

  print 'libmatrix result:', w.toarray()
  print 'reference result:', numpy.dot( A_npy, v_npy )


try:
  test( nprocs=2, size=10 )
except:
  traceback.print_exc()
