#! /usr/bin/python

import libmatrix, traceback, numpy


def test( nprocs, size ):

  print 'testing on %d processors' % nprocs
  print 'total dofs:', size

  print 'row dof assignments:'
  bounds = ( (size-1) * numpy.arange( nprocs+1, dtype=float ) / nprocs ).astype( int )
  rowdofmap = map( numpy.arange, bounds[:-1], bounds[1:]+1 )
  for iproc, dofs in enumerate( rowdofmap ):
    print '  proc %d:' % iproc, dofs

  comm = libmatrix.LibMatrix( nprocs=nprocs )
  rowmap = libmatrix.Map( comm, size, rowdofmap ) # overlapping
  print 'USED: ', rowmap.local2global
  print 'OWNED: ', rowmap.local2global_owned

  block = numpy.array([[1,-1],[-1,1]])
  print 'block:'
  print block

  export = rowmap.export

  v_npy = numpy.arange(1,size+1) * 10

  v = libmatrix.Vector( comm, rowmap )

  for i in range(size-1):
    dofs = numpy.arange(i,i+2)
    values = v_npy[i:i+2] / 2.
    print 'adding', values, ' to ', dofs
    v.add_global( idx=[dofs], data=values )

  v.complete( export )

  v_npy[0] /= 2
  v_npy[-1] /= 2

  print v.toarray()

  print 'resulting vector:', v.toarray()
  print 'reference vector:', v_npy

  norm = v.norm()

  print 'resulting norm:', norm
  print 'reference norm:', numpy.linalg.norm( v_npy )

  print 'sparsity:'
  nzmap = [ [ [] for d in dofs ] for dofs in rowdofmap ]
  for i in range(size-1):
    local = rowmap.global2local[:,i:i+2]
    rank = ( local != -1 ).all( axis=1 ).nonzero()[0][0]
    i, j = local[rank]
    nzmap[rank][i].extend([i,j])
    nzmap[rank][j].extend([i,j])
  nzmap = [ map( numpy.unique, nz ) for nz in nzmap ]
  for iproc, nz in enumerate( nzmap ):
    print '  proc %d:' % iproc, nz
  graph = libmatrix.Graph( comm, rowmap, rowmap, rows=nzmap )

  A = libmatrix.Matrix( comm, graph )
  for i in range(size-1):
    idx = numpy.arange(i,i+2)
    print 'adding block to ', idx
    A.add_global( idx=[idx,idx], data=block )

  #A.add( rank=0, rowidx=[0,size-1], colidx=[0,size-1], data=block )

  A.complete( export )

  A_npy = numpy.eye(size,size) * 2 - numpy.eye(size,size,1) - numpy.eye(size,size,-1)
  A_npy[0,0] = A_npy[-1,-1] = 1

  print 'libmatrix norm:', A.norm()

  print 'multiplying matrix and vector'
  w = A.matvec( v )

  print 'libmatrix result:', w.toarray()
  print 'reference result:', numpy.dot( A_npy, v_npy )

  vectors = []
  numbers = []
  for i in range(size):
    ei = libmatrix.Vector( comm, rowmap )
    ei.add_global( idx=[[i]], data=[1] )
    ei.complete( export )
    print 'unit vector i=%d:' % i, ei.toarray()
    vectors.append( A.matvec( ei ).toarray() )
    numbers.append( v.dot( ei ) )

  B = numpy.array( vectors )
  print B
  print 'reconstructed norm:', numpy.sqrt( ( B**2 ).sum() )
  print 'reference norm:', numpy.sqrt( ( A_npy**2 ).sum() )

  print 'reconstructed vector:', numpy.array( numbers )

  comm.toggle_stdout()

  P = libmatrix.Precon( comm, A, 'ILUT' )
  vv = A.solve( P, w, 'CG' )

  comm.toggle_stdout()

  print 'solve result:', vv.toarray()
  print 'difference:', v.toarray() - vv.toarray()

try:
  test( nprocs=2, size=10 )
except:
  traceback.print_exc()
