#! /usr/bin/python

import libmatrix, traceback, numpy


def test( nprocs, size ):

  print 'testing on %d processors' % nprocs
  print 'total dofs:', size

  print 'row dof assignments:'
  bounds = ( (size-1) * numpy.arange( nprocs+1, dtype=float ) / nprocs ).astype( int )
  rowdofmap = map( numpy.arange, bounds[:-1], bounds[1:]+1 )
  for iproc, dofs in enumerate( rowdofmap ):
    print '  proc %d:' % iproc, dofs

  comm = libmatrix.LibMatrix( nprocs=nprocs )
  comm.set_verbosity( 0 )
  rowmap = libmatrix.Map( comm, rowdofmap, size ) # overlapping
  print 'used:', rowmap.local2global

  block = numpy.array([[1,-1],[-1,1]])
  print 'block:'
  print block

  export = rowmap.export

  v_npy = numpy.arange(1,size+1) * 10

  v = libmatrix.Vector( rowmap )

  for i in range(size-1):
    dofs = numpy.arange(i,i+2)
    values = v_npy[i:i+2] / 2.
    print 'adding', values, ' to ', dofs
    v.add_global( idx=[dofs], data=values )

  v.complete( export )

  v_npy[0] /= 2
  v_npy[-1] /= 2

  print v.toarray()

  print 'resulting vector:', v.toarray()
  print 'reference vector:', v_npy

  norm = v.norm()

  print 'resulting norm:', norm
  print 'reference norm:', numpy.linalg.norm( v_npy )

  A = libmatrix.Matrix( rowmap )
  for i in range(size-1):
    idx = numpy.arange(i,i+2)
    print 'adding block to ', idx
    A.add_global( idx=[idx,idx], data=block )
  A.complete( export )

  A_npy = numpy.eye(size,size) * 2 - numpy.eye(size,size,1) - numpy.eye(size,size,-1)
  A_npy[0,0] = A_npy[-1,-1] = 1

  print 'libmatrix norm:', A.norm()

  print 'multiplying matrix and vector'
  w = A.matvec( v )

  print 'libmatrix result:', w.toarray()
  print 'reference result:', numpy.dot( A_npy, v_npy )

  vectors = []
  numbers = []
  for i in range(size):
    ei = libmatrix.Vector( rowmap )
    ei.add_global( idx=[[i]], data=[1] )
    ei.complete( export )
    print 'unit vector i=%d:' % i, ei.toarray()
    vectors.append( A.matvec( ei ).toarray() )
    numbers.append( v.dot( ei ) )

  B = numpy.array( vectors )
  print B
  print 'reconstructed norm:', numpy.sqrt( ( B**2 ).sum() )
  print 'reference norm:', numpy.sqrt( ( A_npy**2 ).sum() )

  print 'reconstructed vector:', numpy.array( numbers )

  rhs = libmatrix.Vector( rowmap )
  rhs.add_global( [[0]], [5] )
  rhs.complete()
  AA = libmatrix.Matrix( rowmap )
  AA.add_global( idx=[[0],[0]], data=[[1]] )
  AA.complete()
  cons = AA.solve( precon=A, rhs=rhs, name='CG' )

  P = libmatrix.Precon( A, 'ILUT' )
  x = A.solve( precon=P, rhs=w, name='CG', cons=cons )

  print 'solve result:', x.toarray()
  print 'difference:', v.toarray() - x.toarray()

try:
  test( nprocs=2, size=10 )
except:
  traceback.print_exc()
