#! /usr/bin/python

import numpy, sys, time, os, traceback
from mpi4py import MPI


typemap = {
  'int32': (numpy.int32, MPI.INT),
  'int64': (numpy.int64, MPI.LONG),
  'float64': (numpy.float64, MPI.DOUBLE),
}


_info = dict( line.rstrip().split( ': ', 1 ) for line in os.popen( './libmatrix.mpi info' ) )

def bcast_token( func, names=_info.pop('token')[5:-1].split(', ') ):
  token = chr( names.index( func.func_name ) )
  def wrapped( self, *args, **kwargs ):
    assert self.comm.isconnected(), 'connection is closed'
    self.comm.bcast( token, TOKEN )
    return func( self, *args, **kwargs )
  return wrapped

LOCAL  = typemap[ _info.pop('local')  ]
GLOBAL = typemap[ _info.pop('global') ]
HANDLE = typemap[ _info.pop('handle') ]
SIZE   = typemap[ _info.pop('size')   ]
SCALAR = typemap[ _info.pop('scalar') ]
TOKEN  = numpy.character, MPI.CHAR

assert not _info
del _info


class InterComm( object ):

  def __init__( self, nprocs ):
    self.__comm = MPI.COMM_SELF.Spawn( 'libmatrix.mpi', args=['eventloop'], maxprocs=nprocs )
    assert self.__comm.remote_size == nprocs
    self.size = nprocs

  def isconnected( self ):
    return bool( self.__comm )

  def bcast( self, data, (npytype,mpitype) ):
    data = numpy.asarray( data, npytype )
    self.__comm.Bcast( [ data, mpitype ], root=MPI.ROOT )
  
  def gather( self, (npytype,mpitype) ):
    array = numpy.empty( self.size, dtype=npytype )
    self.__comm.Gather( None, [ array, mpitype ], root=MPI.ROOT )
    return array
  
  def gather_equal( self, dtype ):
    array = self.gather( dtype )
    assert numpy.all( array[1:] == array[0] )
    return array[0]
  
  def scatter( self, array, (npytype,mpitype) ):
    array = numpy.asarray( array, dtype=npytype )
    self.__comm.Scatter( [ array, mpitype ], None, root=MPI.ROOT )
  
  def scatterv( self, arrays, (npytype,mpitype) ):
    arrays = [ numpy.asarray( array, dtype=npytype ) for array in arrays ]
    lengths = map( len, arrays )
    offsets = numpy.concatenate( [ [0], numpy.cumsum( lengths[:-1] ) ] ) # first offset = 0
    concatarray = numpy.concatenate( arrays )
    self.__comm.Scatterv( [ concatarray, lengths, offsets, mpitype ], None, root=MPI.ROOT )
  
  def gatherv( self, lengths, (npytype,mpitype) ):
    array = numpy.empty( 20, dtype=npytype )
    offsets = numpy.concatenate( [ [0], numpy.cumsum( lengths[:-1] ) ] ) # first offset = 0
    self.__comm.Gatherv( None, [ array, lengths, offsets, mpitype ], root=MPI.ROOT )
    return [ array[i:i+n] for i, n in zip( offsets, lengths ) ]
  
  def send( self, rank, array, (npytype,mpitype) ):
    array = numpy.asarray( array, npytype )
    self.__comm.Send( [ array, mpitype ], rank, tag=0 )

  def verify( self ):
    raise NotImplementedError
    strlen = self.gather( int )
    good = (strlen == 0)
    if good.all():
      return 0
    msgs = [ 'In libmatrix: %d errors occurred:' % (~good).sum() ]
    for i, s in enumerate( strlen ):
      if s:
        x = numpy.empty( s, dtype='c' )
        self.__comm.Recv( [x,MPI.CHAR], i, tag=10 )
        msgs.append( '[%d] %s' % ( i, x.tostring() ) )
    raise Exception( '\n  '.join( msgs ) )

  def disconnect( self ):
    if self.isconnected():
      self.bcast( '\xff', TOKEN )
      self.__comm.Disconnect()

  def __del__( self ):
    self.disconnect()


class Map( object ):

  def __init__( self, comm, globs ):
    self.comm = comm
    assert len(globs) == comm.size
    self.globs = [ numpy.asarray(glob,dtype=int) for glob in globs ]
    self.handle = self.new_map()

  @bcast_token
  def new_map( self ):
    lengths = map( len, self.globs )
    size = sum( lengths ) # TODO check meaning of size in map constructor
    self.comm.bcast( size, SIZE )
    self.comm.scatter( lengths, SIZE )
    self.comm.scatterv( self.globs, GLOBAL )
    return self.comm.gather_equal( HANDLE )


class Vector( object ):

  def __init__( self, comm, size, mp ):
    self.comm = comm
    self.size = size
    assert isinstance( mp, Map )
    self.mp = mp
    self.handle = self.new_vector()

  @bcast_token
  def new_vector( self ):
    self.comm.bcast( self.mp.handle, HANDLE )
    return self.comm.gather_equal( HANDLE )

  @bcast_token
  def add_evec( self, rank, idx, data ):
    n = len(idx)
    assert len(data) == n
    self.comm.bcast( rank, SIZE )
    self.comm.send( rank, self.handle, HANDLE )
    self.comm.send( rank, n, SIZE )
    self.comm.send( rank, idx, GLOBAL )
    self.comm.send( rank, data, SCALAR )

  @bcast_token
  def get_vector( self ):
    self.comm.bcast( self.handle, HANDLE )
    lengths = map( len, self.mp.globs )
    array = numpy.zeros( self.size ) # TODO fix length
    local_arrays = self.comm.gatherv( lengths, SCALAR )
    for idx, local_array in zip( self.mp.globs, local_arrays ):
      array[idx] += local_array
    return array


class Matrix( object ):

  def __init__( self, comm, shape, graph ):
    self.comm = comm
    self.shape = shape
    assert isinstance( graph, Graph )
    self.graph = graph
    self.handle = self.new_matrix()

  @bcast_token
  def new_matrix( self ):
    self.comm.bcast( self.graph.handle, HANDLE )
    return self.comm.gather_equal( HANDLE )

  @bcast_token
  def add_emat( self, rank, rowidx, colidx, data ):
    data = numpy.asarray(data)
    shape = len(rowidx), len(colidx)
    assert data.shape == shape
    self.comm.bcast( rank, SIZE )
    self.comm.send( rank, self.handle, HANDLE )
    self.comm.send( rank, shape, SIZE )
    print rowidx, colidx
    self.comm.send( rank, rowidx, GLOBAL )
    self.comm.send( rank, colidx, GLOBAL )
    self.comm.send( rank, data.ravel(), SCALAR )

  @bcast_token
  def fill_complete( self ):
    self.comm.bcast( self.handle, HANDLE )

  @bcast_token
  def matrix_norm( self ):
    self.comm.bcast( self.handle, HANDLE )
    return self.comm.gather_equal( SCALAR )

  def matvec( self, vec ):
    out = Vector( self.comm, self.shape[0], self.graph.mp )
    self.matvec_inplace( out, vec )
    return out

  @bcast_token
  def matvec_inplace( self, out, vec ):
    assert isinstance( vec, Vector )
    assert isinstance( out, Vector )
    assert self.shape == ( out.size, vec.size )
    self.comm.bcast( [ self.handle, out.handle, vec.handle ], HANDLE )


class Graph( object ):

  def __init__( self, comm, mp, rows ):
    self.comm = comm
    assert isinstance( mp, Map )
    self.mp = mp
    self.handle = self.new_graph( rows )

  @bcast_token
  def new_graph( self, rows ):
    self.comm.bcast( self.mp.handle, HANDLE )
    numcols = [ map( len, row ) for row in rows ]
    self.comm.scatterv( numcols, SIZE )
    cols = [ numpy.concatenate( row ) for row in rows ]
    self.comm.scatterv( cols, GLOBAL )
    return self.comm.gather_equal( HANDLE )


def test1proc():

  comm = InterComm( nprocs=1 )

  try:

    m = Map( comm, globs=[(0,1,2,3,4,5)] )

    v = Vector( comm, m )
    v.add_evec( rank=0, idx=[1,2,4,5], data=[10,20,30,40] )

    print v.get_vector()

    graph = Graph( comm, m, rows=[([0,1],[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5])] )

    A = Matrix( comm, (10,10), graph )
    A.add_emat( rank=0, rowidx=[0,1], colidx=[0,1], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=0, rowidx=[1,2], colidx=[1,2], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=0, rowidx=[2,3], colidx=[2,3], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=0, rowidx=[3,4], colidx=[3,4], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=0, rowidx=[4,5], colidx=[4,5], data=[[1,-1],[-1,1]] )

    A.fill_complete()
    #A.add_emat( rank=0, rowidx=[1,2], colidx=[2,1], data=[[1,-1],[-1,1]] )

    N = 6
    Anumpy = numpy.eye(N,N) * 2 - numpy.eye(N,N,1) - numpy.eye(N,N,-1)
    Anumpy[0,0] = 1
    Anumpy[-1,-1] = 1
    print Anumpy
    print 'norm a:', numpy.sqrt( ( Anumpy**2 ).sum() )
    print 'norm b:', A.matrix_norm()

  except:

    traceback.print_exc()

  finally:

    comm.disconnect()


def test2proc():

  comm = InterComm( nprocs=2 )

  try:

    m = Map( comm, globs=[(0,1,2,3,4,5),(5,6,7,8,9)] )

    v = Vector( comm, 10, m )
    v.add_evec( rank=0, idx=[1,2,4,5], data=[10,20,30,40] )
    v.add_evec( rank=1, idx=[5,7], data=[10,20] )

    print v.get_vector()

    graph = Graph( comm, m, rows=[([0,1],[0,1,2],[1,2,3],[2,3,4],[3,4,5],[4,5]),([5,6],[5,6,7],[6,7,8],[7,8,9],[8,9])] )

    A = Matrix( comm, (10,10), graph )
    A.add_emat( rank=0, rowidx=[0,1], colidx=[0,1], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=0, rowidx=[1,2], colidx=[1,2], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=0, rowidx=[2,3], colidx=[2,3], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=0, rowidx=[3,4], colidx=[3,4], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=0, rowidx=[4,5], colidx=[4,5], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=1, rowidx=[5,6], colidx=[5,6], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=1, rowidx=[6,7], colidx=[6,7], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=1, rowidx=[7,8], colidx=[7,8], data=[[1,-1],[-1,1]] )
    A.add_emat( rank=1, rowidx=[8,9], colidx=[8,9], data=[[1,-1],[-1,1]] )

    A.fill_complete()
    #A.add_emat( rank=0, rowidx=[1,2], colidx=[2,1], data=[[1,-1],[-1,1]] )

    N = 10
    Anumpy = numpy.eye(N,N) * 2 - numpy.eye(N,N,1) - numpy.eye(N,N,-1)
    Anumpy[0,0] = 1
    Anumpy[-1,-1] = 1
    print Anumpy
    print 'norm a:', numpy.sqrt( ( Anumpy**2 ).sum() )
    print 'norm b:', A.matrix_norm()


    w = A.matvec( v )
    print w.get_vector()

  except:

    traceback.print_exc()

  finally:

    comm.disconnect()


def main():

  #test1proc()
  test2proc()

main()
